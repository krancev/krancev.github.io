<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数组数组：二分查找法（Leetcode 704)双指针。看区间是左闭右闭，或者左闭右开 1234567891011121314151617181920&#x2F;&#x2F;一般如何判断while(left &lt; right)或者while(left &lt;&#x3D; right)&#x2F;&#x2F; 或者right &#x3D; mid 或者 right &#x3D; mid - 1;&#x2F;&#x2F; 左闭右闭如果是[left,right]的左闭右闭区间，那么le">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/09/24/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数组数组：二分查找法（Leetcode 704)双指针。看区间是左闭右闭，或者左闭右开 1234567891011121314151617181920&#x2F;&#x2F;一般如何判断while(left &lt; right)或者while(left &lt;&#x3D; right)&#x2F;&#x2F; 或者right &#x3D; mid 或者 right &#x3D; mid - 1;&#x2F;&#x2F; 左闭右闭如果是[left,right]的左闭右闭区间，那么le">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-24T02:20:33.352Z">
<meta property="article:modified_time" content="2023-09-20T12:18:49.480Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/09/24/%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-09-24T02:20:33.352Z" itemprop="datePublished">2023-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组：二分查找法（Leetcode-704"><a href="#数组：二分查找法（Leetcode-704" class="headerlink" title="数组：二分查找法（Leetcode 704)"></a>数组：二分查找法（Leetcode 704)</h2><p><strong>双指针</strong>。看区间是左闭右闭，或者左闭右开</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般如何判断while(left &lt; right)或者while(left &lt;= right)</span></span><br><span class="line"><span class="comment">// 或者right = mid 或者 right = mid - 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭</span></span><br><span class="line">如果是[left,right]的左闭右闭区间，那么left = right是合法的，使用</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">如果在上述条件下</span><br><span class="line">     <span class="keyword">if</span>(nums[middle] &gt; target)</span><br><span class="line">         right = middle - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line"> 那么下一次是right = middle - <span class="number">1</span>，因为已经判断过了target一定大于middle</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开  [1,1)</span></span><br><span class="line"> 如果是[left,right]的左闭右开区间，那么left = right是不合法的，不可能left为<span class="number">1</span>，right也为<span class="number">1</span>，因为是开区间，取不到</span><br><span class="line">     <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    <span class="keyword">if</span>(nums[middle] &gt; target) <span class="comment">//本来就取不到右边界</span></span><br><span class="line">         right = middle;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数组：移除元素（Leetcode-27"><a href="#数组：移除元素（Leetcode-27" class="headerlink" title="数组：移除元素（Leetcode 27)"></a>数组：移除元素（Leetcode 27)</h2><p>vector的erase可以删除元素，erase是一个o(n)的操作</p>
<p><strong>快慢指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slow是新数组的下标值,需要更新的下标</span></span><br><span class="line"><span class="comment">// fast的快指针寻找新数组需要的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>;fast &lt; nums.<span class="built_in">size</span>();fast ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[fast] !=target)</span><br><span class="line">        nums[slow++] = nums[fast];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组：有序数组的平方（Leetcode-977"><a href="#数组：有序数组的平方（Leetcode-977" class="headerlink" title="数组：有序数组的平方（Leetcode 977)"></a>数组：有序数组的平方（Leetcode 977)</h2><p><strong>双指针</strong>：为什么用双指针，因为题目要求的Nums是一个非递减顺序，本质是一个递增，而数组里面又有负数，如果没有负数，最大的一定是数组最右元素。现在有负数，最大元素一定是两边的元素往中间走。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"><span class="type">int</span> k = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>,j = nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=j;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] * nums[i] &gt;= nums[j] *nums[j])</span><br><span class="line">    &#123;</span><br><span class="line">        result[k--] = nums[i] * nums[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        result[k--] = nums[j] * nums[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组：长度最小的数组（Leetcode-209"><a href="#数组：长度最小的数组（Leetcode-209" class="headerlink" title="数组：长度最小的数组（Leetcode 209)"></a>数组：长度最小的数组（Leetcode 209)</h2><p>暴力解法：使用两个for循环，第一个遍历所有的起始位置，第二个遍历所有的终止位置，找到所有的可能区间再取最小值</p>
<p><strong>滑动窗口</strong>：用一个for循环解决问题，如果for循环里面是起始位置，那么终止位置照样需要遍历所有的可能情况。和暴力解法差不多，所以实际上滑动窗口的for循环里面是终止位置</p>
<ul>
<li>for循环是终止位置</li>
<li><strong>如何移动起始位置</strong>（精髓）（找到终止位置后收缩起始位置）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += nums[j];</span><br><span class="line">    <span class="keyword">while</span>(sum &gt;= s)</span><br><span class="line">    &#123;</span><br><span class="line">        subL = j- i+<span class="number">1</span>;</span><br><span class="line">        result = <span class="built_in">min</span>(subL,result);</span><br><span class="line">        sum = sum - nums[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组：螺旋矩阵（Leetcode-59"><a href="#数组：螺旋矩阵（Leetcode-59" class="headerlink" title="数组：螺旋矩阵（Leetcode 59)"></a>数组：螺旋矩阵（Leetcode 59)</h2><ul>
<li><p><strong>一个转圈的问题，难在了边界问题</strong></p>
</li>
<li><p><strong>遵循循环不变量，每一条边一定要处理成一样的条件</strong>。例如左闭右开，如果每条边是左闭右闭，下一条边只能左开右闭，最后一条边只能左开右开。</p>
</li>
<li><p><strong>循环的次数是N&#x2F;2</strong>。如果n是奇数的话，就会留中间那个数，只需要单独给他赋值就可以了。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> startX  = <span class="number">0</span>,startY = <span class="number">0</span>,offset = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loop = n /<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> mid = n /<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(loop--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = startY;j&lt;n-offset;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[startX][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = startX;i&lt;n-offset;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&gt;startY;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;startX;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i][j] = count++;</span><br><span class="line">    &#125;</span><br><span class="line">    startX++;</span><br><span class="line">    startY++;</span><br><span class="line">    offset++;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nums[mid][mid] = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表：移除链表元素-leetcode-203"><a href="#链表：移除链表元素-leetcode-203" class="headerlink" title="链表：移除链表元素(leetcode  203)"></a>链表：移除链表元素(leetcode  203)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对  头结点  和  非头结点  移除的方式是不一样的。</span></span><br><span class="line"><span class="comment">// 如果使用了虚拟头结点都可以按照一样的方法</span></span><br><span class="line">ListNode * dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">dummyhead-&gt;next = head;</span><br><span class="line">ListNode *cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyhead-&gt;next;</span><br></pre></td></tr></table></figure>

<h2 id="链表：设计链表（leetcode-707）"><a href="#链表：设计链表（leetcode-707）" class="headerlink" title="链表：设计链表（leetcode  707）"></a>链表：设计链表（leetcode  707）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取第几个结点的值</span></span><br><span class="line">ListNode * cur = dummyhead-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、头部插入结点</span></span><br><span class="line">ListNode *newnode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">newnode-&gt;next = dummyhead-&gt;next;</span><br><span class="line">dummyhead-&gt;next = newnode;</span><br><span class="line"><span class="comment">//3、尾部插入结点</span></span><br><span class="line">ListNode *newnode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">ListNode *cur = dummyhead-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newnode;</span><br><span class="line"><span class="comment">//4、第n个结点前插入结点</span></span><br><span class="line">ListNode *newnode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">ListNode *cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newnode;</span><br><span class="line">size++;</span><br><span class="line"><span class="comment">//5、删除第n个结点(记得释放内存~~~)</span></span><br><span class="line">ListNode *cur = dummyhead;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链表：翻转链表（leetcode-206）"><a href="#链表：翻转链表（leetcode-206）" class="headerlink" title="链表：翻转链表（leetcode  206）"></a>链表：翻转链表（leetcode  206）</h2><ul>
<li>双指针</li>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针</span></span><br><span class="line">ListNode * cur = head;</span><br><span class="line">ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    ListNode *tmp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="comment">// 完全看双指针的写法</span></span><br><span class="line"><span class="built_in">reverse</span>(cur,pre)&#123;</span><br><span class="line">    <span class="comment">// 查看while循环终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = pre;</span><br><span class="line">    <span class="comment">// 查看上面的赋值操作</span></span><br><span class="line">   <span class="built_in">reverse</span>(tmp,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverseList</span>(head)&#123;</span><br><span class="line">    <span class="comment">// 参照上面初始化的时候 cur = head, pre = nullptr;</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">reverse</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表：两两交换链表中的节点（leetcode-24）"><a href="#链表：两两交换链表中的节点（leetcode-24）" class="headerlink" title="链表：两两交换链表中的节点（leetcode  24）"></a>链表：两两交换链表中的节点（leetcode  24）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode * dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">dummyhead-&gt;next = head;</span><br><span class="line">ListNode *cur = dummyhead;</span><br><span class="line"><span class="comment">// 如果节点数量为偶数的时候，cur-&gt;next = NULL就结束了</span></span><br><span class="line"><span class="comment">// 如果节点数量为奇数的时候，cur-&gt;next -&gt;next = NULL就结束了</span></span><br><span class="line"><span class="comment">// 顺序不能反！！！如果cur-&gt;next == NULL，那取不到cur-&gt;next-&gt;next</span></span><br><span class="line"><span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    ListNode *tmp = cur-&gt;next;</span><br><span class="line">    ListNode *tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">    cur-&gt;next-&gt;next = tmp;</span><br><span class="line">    cur-&gt;next-&gt;next-&gt;next = tmp1; </span><br><span class="line">    </span><br><span class="line">    cur = cur-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链表：删除链表倒数第N个节点（leetcode-19）"><a href="#链表：删除链表倒数第N个节点（leetcode-19）" class="headerlink" title="链表：删除链表倒数第N个节点（leetcode  19）"></a>链表：删除链表倒数第N个节点（leetcode  19）</h2><p><strong>快慢指针</strong>：先让<strong>快指针先移动N步，再让快慢指针同时移动</strong>，当快指针指向NULL的时候，慢指针指向我们要的节点。</p>
<p>但是<strong>删除指针需要该指针的前一个指针，这时候需要让快指针多走一步</strong>，快指针走n+1步，再同时移动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode *slow = dummyhead,*fast = dummyhead;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>)</span><br><span class="line">    fast = fast -&gt;next;</span><br><span class="line"><span class="keyword">while</span>(fast != null)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode *tmp = slow-&gt;next;</span><br><span class="line">slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> dummyhead-&gt;next;</span><br></pre></td></tr></table></figure>

<h2 id="链表：快慢指针（leetcode-142）"><a href="#链表：快慢指针（leetcode-142）" class="headerlink" title="链表：快慢指针（leetcode  142）"></a>链表：快慢指针（leetcode  142）</h2><p><strong>快慢指针</strong>：慢指针走一步，快指针走两步。他两一定能在环里相遇</p>
<p>（<strong>为什么一定相遇？</strong>：快指针对于慢指针的相对运动来说，每次就移动了一步，所以一定会相遇）</p>
<p><strong>如何算环的入口处</strong>：假设共同走的路程是<strong>x</strong>，到相遇位置<strong>慢指针</strong>走了<strong>y,<strong>与环还差</strong>z</strong>的路程。</p>
<blockquote>
<p>slow &#x3D; x + y; （为什么慢指针一定在第一圈被追上？）</p>
<p>fast &#x3D; x + y + n(y+z); ( n是快指针走了n圈)</p>
<p>所以 2 * slow &#x3D; fast;   </p>
<p>2(x+y) &#x3D; x + y + n(y+z)；</p>
<p>x + y &#x3D; n(y+z)</p>
<p>x &#x3D; n(y+z) - y  （n &gt;&#x3D; 1)</p>
<p>x &#x3D; (n-1)(y+z) + z  如果n &#x3D; 1</p>
<p>x &#x3D; z</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要判断快指针是否为空，又因为两步两步跳的所以要判断</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast -&gt;next -&gt;next;</span><br><span class="line">    slow = slow -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(fast == slow)</span><br><span class="line">    &#123;</span><br><span class="line">        index1 = fast;</span><br><span class="line">        index2 = head;</span><br><span class="line">        <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">            index1 = index1-&gt;next;</span><br><span class="line">            index2 = index2 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表：有效的字母异位词（leetcode-242）"><a href="#哈希表：有效的字母异位词（leetcode-242）" class="headerlink" title="哈希表：有效的字母异位词（leetcode  242）"></a><strong>哈希表：有效的字母异位词（leetcode  242）</strong></h2><p>哈希表有三种数据结构:</p>
<ul>
<li><strong>数组</strong>：范围可控，比如26个字母</li>
<li><strong>set</strong>：数值很大</li>
<li><strong>map</strong>：如果Key对应一个value的话</li>
</ul>
<p>主要是<strong>本体都是小写字母，就可以使用数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hash[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    hash[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)</span><br><span class="line">    hash[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表：求两个数组的交集（leetcode-349）"><a href="#哈希表：求两个数组的交集（leetcode-349）" class="headerlink" title="哈希表：求两个数组的交集（leetcode  349）"></a>哈希表：求两个数组的交集（leetcode  349）</h2><ul>
<li>可以用set或者数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line">对Nums1转换成hash表</span><br><span class="line">再在nums2对hash查询是否出现过</span><br><span class="line">出现过就放在result里面</span><br><span class="line">    </span><br><span class="line">c++ 有三个set集合:</span><br><span class="line"><span class="number">1</span>、set</span><br><span class="line"><span class="number">2</span>、unordered_set</span><br><span class="line"><span class="number">3</span>、multi_set</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//set</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">    <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">    <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class="line"><span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 默认数值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123; <span class="comment">// nums1中出现的字母在hash数组中做记录</span></span><br><span class="line">    hash[num] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123; <span class="comment">// nums2中出现话，result记录</span></span><br><span class="line">    <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) &#123;</span><br><span class="line">        result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="哈希表：两数之和（leetcode-1）"><a href="#哈希表：两数之和（leetcode-1）" class="headerlink" title="哈希表：两数之和（leetcode  1）"></a>哈希表：两数之和（leetcode  1）</h2><p><strong>这道题之前的思路是使用一个map来存nums，然后再遍历一遍数组查看taget - nums[i]是否存在数组里面。其实也是o(n)的复杂度。不过下面这种思路一个for循环就搞定了。而且注意使用unordered_map（不需要排序）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line">std::unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">    <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]); </span><br><span class="line">    <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">    map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表：四数相加（leetcode-454）"><a href="#哈希表：四数相加（leetcode-454）" class="headerlink" title="哈希表：四数相加（leetcode  454）"></a>哈希表：四数相加（leetcode  454）</h2><p>暴力解法是4个for循环，为了减少时间复杂度吧。可以先将A+B数组的值存一个map，再将C+D数组的值，主要是0 - (c+d)，因为0 - (c+d) 是否 &#x3D; a+b嘛，查一下存不存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> a:nums1)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> b:nums2)</span><br><span class="line">        mp[a+b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:nums3)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> d:nums4)&#123;</span><br><span class="line">        <span class="type">int</span> target = <span class="number">0</span> -(c+d);</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(target)!=mp.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            count += mp[target];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表：三数之和（leetcode-15）"><a href="#哈希表：三数之和（leetcode-15）" class="headerlink" title="哈希表：三数之和（leetcode  15）"></a>哈希表：三数之和（leetcode  15）</h2><p>这道题主要是<strong>题目需要去重</strong>。</p>
<p>可以使用map或者双指针（但是双指针需要去重，就很麻烦）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 注意！！！这里不能用nums[i] = nums[i+1]！！！，因为i+1相当于left，是另一个数了</span></span><br><span class="line">    <span class="comment">// 你只能nums[i] = num[i-1];</span></span><br><span class="line">    <span class="keyword">if</span>(i &amp;&amp; nums[i] == num[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> left = i + <span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) <span class="comment">// left和right不能相等</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((nums[i] + nums[left] + nums[right]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((nums[i] + nums[left] + nums[right]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">// 但是b,c也需要去重</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left &amp;&amp; right[i] == right[i<span class="number">-1</span>])</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left &amp;&amp; left[i] == left[i+<span class="number">1</span>])</span><br><span class="line">                left++;</span><br><span class="line">             right--;</span><br><span class="line">             left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表：四数之和（leetcode-18）"><a href="#哈希表：四数之和（leetcode-18）" class="headerlink" title="哈希表：四数之和（leetcode  18）"></a>哈希表：四数之和（leetcode  18）</h2><p>在<strong>三数之和的基础上再套上一个循环K</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//先剪枝</span></span><br><span class="line"><span class="comment">// 一级剪枝</span></span><br><span class="line"><span class="keyword">if</span>(nums[k] &gt; target &amp;&amp; nums[k] &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 一级去重</span></span><br><span class="line"><span class="keyword">if</span>( k &gt;<span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k +<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 二级剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(nums[k] + nums[i] &gt; target &amp;&amp; (nums[k] + nums[i]) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 二级去重</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; k+<span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    ......</span><br><span class="line">        ......</span><br><span class="line">        	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>算法性的思路，<strong>字符串和数组差不多</strong></p>
<h2 id="字符串：反转字符串-leetcode-344"><a href="#字符串：反转字符串-leetcode-344" class="headerlink" title="字符串：反转字符串(leetcode 344)"></a>字符串：反转字符串(leetcode 344)</h2><p>​	需要原地操作，双指针啦~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(s[l++],s[r--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串：反转字符串II-leetcode-541"><a href="#字符串：反转字符串II-leetcode-541" class="headerlink" title="字符串：反转字符串II(leetcode 541)"></a>字符串：反转字符串II(leetcode 541)</h2><p>感觉官方题解好一点点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>(); i+= <span class="number">2</span>*k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这是直接调用库函数了吧。也可以自己写</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + <span class="built_in">min</span>(i+k,n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>

<h2 id="字符串：翻转字符串里的单词-leetcode-151"><a href="#字符串：翻转字符串里的单词-leetcode-151" class="headerlink" title="*字符串：翻转字符串里的单词(leetcode 151)"></a>*字符串：翻转字符串里的单词(leetcode 151)</h2><p>可以先把原字符串全部翻转，然后再把每个单词反回来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先思想还是快慢指针，首先需要把全部多余的空格去掉</span></span><br><span class="line"><span class="comment">// 但是需要考虑特殊情况，比如第一个单词之前不能有空格，最后一个单词之后不能有空格</span></span><br><span class="line"><span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>;fast &lt; s.<span class="built_in">size</span>();fast++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[fast] != <span class="string">&#x27; &#x27;</span>) <span class="comment">// 只要fast不为空，就进行赋值的操作，fast一定是走的比slow快的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slow != <span class="number">0</span>) <span class="comment">// 专门用来处理第一个字母之前的空格的特殊情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fast] != <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[slow++] = s[fast++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span> || i == s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + start,s.<span class="built_in">begin</span>() + i);</span><br><span class="line">            start = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="★记得自己看解法！！！这里讲的不好；字符串：KMP算法（Leetcode-）"><a href="#★记得自己看解法！！！这里讲的不好；字符串：KMP算法（Leetcode-）" class="headerlink" title="★记得自己看解法！！！这里讲的不好；字符串：KMP算法（Leetcode ???）"></a>★记得自己看解法！！！这里讲的不好；字符串：KMP算法（Leetcode ???）</h2><p><strong>KMP算法</strong>解决的是<strong>字符串匹配</strong>的问题。（前缀表）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文本串：aabaabaafa</span><br><span class="line">模式串:  aabaaf</span><br><span class="line"></span><br><span class="line">注意：f前面的子串aabaa。后缀是aa，前缀也是aa。后缀与他相等的前缀就是前面的aa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前缀表：</p>
<ul>
<li>前缀：前缀是包含首字母，不包含尾字母的所有子串都是前缀<ul>
<li>a</li>
<li>aa</li>
<li>aab</li>
<li>aaba</li>
<li>aabaa</li>
</ul>
</li>
<li>后缀：<ul>
<li>f</li>
<li>af</li>
<li>aaf</li>
<li>baaf</li>
<li>abaaf</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>需要最长相等的前后缀</strong>，看aabaaf这个字符串：</p>
<ul>
<li><p>a： 没有前缀和后缀，0</p>
</li>
<li><p>aa: 前缀a，后缀也是a，1</p>
</li>
<li><p>aab: 前缀a，后缀b,  0</p>
</li>
<li><p>aaba: 前缀a，后缀a，1</p>
</li>
<li><p>aabaa: 前缀aa，后缀aa ，2 </p>
</li>
<li><p>aabaaf：没有前缀和后缀   0</p>
<p>模式串的前缀表是：[ 0 , 1 , 0 , 1, 2 ,0]</p>
</li>
</ul>
<p>看模式串和文本串，模式串在<strong>f</strong>的时候和文本串不匹配了，这时候看<strong>f前面的子串</strong>的<strong>最长相等前后缀</strong>，就是a<strong>记录的数值2</strong>，所以直接去2那里找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模式串:a a b a a f</span><br><span class="line">      <span class="number">0</span>  <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span>   找前一位对应的下标</span><br><span class="line">   <span class="comment">//有的会整体右移</span></span><br><span class="line">      <span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>   找本身对应的下标</span><br><span class="line">   <span class="comment">//或者整体减一</span></span><br><span class="line">      <span class="number">-1</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">-1</span></span><br><span class="line"><span class="comment">// 代码代码代码~~~~</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;next,string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化  i表示后缀末尾，j表示前缀末尾</span></span><br><span class="line">    j = <span class="number">0</span>;next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理前后缀不相同的情况</span></span><br><span class="line">    <span class="comment">// 处理前后相同的情况</span></span><br><span class="line">    <span class="comment">// 更新next的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="★注意看解法；字符串：重复的子字符串-leetcode-459"><a href="#★注意看解法；字符串：重复的子字符串-leetcode-459" class="headerlink" title="★注意看解法；字符串：重复的子字符串(leetcode 459)"></a>★注意看解法；字符串：重复的子字符串(leetcode 459)</h2><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈：用栈来实现队列（Leetcode-232）"><a href="#栈：用栈来实现队列（Leetcode-232）" class="headerlink" title="栈：用栈来实现队列（Leetcode 232）"></a>栈：用栈来实现队列（Leetcode 232）</h2><p><strong>可以用两个栈来实现队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stackIn.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackOut.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stackIn.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            stackOut.<span class="built_in">push</span>(stackIn.<span class="built_in">top</span>());</span><br><span class="line">            stackIn.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = stackOut.<span class="built_in">top</span>();</span><br><span class="line">    stackOut.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈：用队列来实现栈-leetcode-225"><a href="#栈：用队列来实现栈-leetcode-225" class="headerlink" title="栈：用队列来实现栈(leetcode 225)"></a>栈：用队列来实现栈(leetcode 225)</h2><p>把1,2弹出来再加入到队列里，如果有size个元素，就把size-1的弹出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    que.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size = que.<span class="built_in">size</span>();</span><br><span class="line">    size--; <span class="comment">// 弹出size-1的元素</span></span><br><span class="line">    <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈：有效的括号（leetcode-20"><a href="#栈：有效的括号（leetcode-20" class="headerlink" title="栈：有效的括号（leetcode 20)"></a>栈：有效的括号（leetcode 20)</h2><p>可以有两种方法：</p>
<ul>
<li>一种是，碰到左括号就放入，碰到右括号就弹出看是否匹配</li>
<li>二种是，碰到左括号就放入右括号，碰到右括号就消消乐</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">char</span>&gt; sd;</span><br><span class="line"><span class="comment">//剪枝</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        sd.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        sd.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        sd.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sd.<span class="built_in">top</span>() != s[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/09/24/%E7%AE%97%E6%B3%95/" data-id="clmwu1pdw0003zot2b76a8hu0" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/09/24/My-New-Post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">My New Post</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/24/%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/24/My-New-Post/">My New Post</a>
          </li>
        
          <li>
            <a href="/2023/09/24/Unity2d/">Unity2D</a>
          </li>
        
          <li>
            <a href="/2023/09/24/Unity3d/">Unity3D</a>
          </li>
        
          <li>
            <a href="/2023/09/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>